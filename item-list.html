<!--
@license
Copyright (c) 2015 Peter Kaske <p.kaske@gmail.com>. All rights reserved.
This code may only be used under the MIT license found at http://opensource.org/licenses/MIT.
Or see the LICENSE file that comes with this code.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../fast-fuzzy-search/fast-fuzzy-search.html">
<link rel="import" href="../iron-selector/iron-selector.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">

<!--
Simple list of items that can be used to build drop-downs or other item list based things. Build with Polymer.

@group GUI Elements
@element item-list-crudbox
@demo demo/index.html
@homepage https://pkaske.github.io/item-list-crudbox
-->

<dom-module id="item-list">
  <style>
    :host {
      display: block;
      background: #FAFAFA;
      outline: 0;
      position: relative;

      @apply(--item-list);
    }

    div.item:focus {
      background: #EEEEEE;
    }

    div.item:not([disabled]).iron-selected {
      background: #4FC3F7;
      color: #FFFFFF;
    }

    .item {
      outline: 0;
      @apply(--layout-horizontal);
      @apply(--layout-center);
      cursor: pointer;
      padding: 5px 10px;
    }

    .item:hover {
      background: #E0F7FA;
    }

    .item[disabled] {
      color: #9E9E9E;
      pointer-events: none;
    }
  </style>
  <template>
    <!-- Provides fuzzy search -->
    <fast-fuzzy-search id="fuzzySearch" term="[[filterTerm]]" path="[[paths.search]]" input="[[items]]" output={{_filteredItems}}></fast-fuzzy-search>

    <iron-selector id="list" class="selector" attr-for-selected="item-id" selected="{{_tmpSelection}}">
      <template is="dom-repeat" items="{{_filteredItems}}">
        <div item-id$="{{_computeItemId(item)}}" class="item" disabled$="{{_computeItemDisabled(item)}}">
          <div class="label">{{item.name}}</div>
        </div>
      </template>
    </iron-selector>
  </template>
  <script>
    Polymer({
      is: 'item-list',

      properties: {
        /**
         * List items to render
         * @type {Array}
         */
        items: {
          type: Array
        },

        /**
         * Id of the selected item.
         */
        selection: {
          type: String,
          notify: true,
          observer: '_selectionChanged'
        },

        /**
         * Paths inside the item objects to find various infos to build and run the list:
         *
         * Uses Polymer.Base.get() compatible syntax.
         * id: The id for the list entries (Default: 'id')
         * search: The field to perform the fuzzy searches in (Default: 'label')
         * disabled: If this field is true, the according list entry will be shown as disabled.
         */
        paths: {
          type: Object,
          value: function(obj) {
            var setPaths = obj.paths || {};

            return this.mixin({
              id: 'id',
              search: 'label',
              disabled: null
            }, setPaths);
          }
        },

        /**
         * Provide callback functions for various list operations here.
         * Every callback gets the current item as the first argument.
         *
         * id: Must return the id to set for the current item's element.
         * search: Must return the haystack to search in.
         * disabled: Must return boolean true if the item disabled, false otherwise.
         */
        pathFunctions: {
          type: Object,
          value: function(obj) {
            var pathFunc = obj.pathFunctions || {};

            return this.mixin({
              id: null,
              disabled: null
            }, pathFunc);
          }
        },

        /**
         * The currently selected item.
         */
        selectedItem: {
          type: Object
        },

        /**
         * The currently focused item.
         */
        focusedItem: {
          type: Object
        },

        /**
         * The list will be narrowed down to only the matching itmes.
         */
        filterTerm: {
          type: String,
          value: '',
          observer: '_filterTermChanged'
        },

        /**
         * The element will search for the first matching item and focus it.
         */
        searchTerm: {
          type: String,
          value: '',
          observer: '_searchTermChanged'
        },

        /**
         * List of items after filtered by fuzzy search.
         */
        _filteredItems: {
          type: Array,
          observer: '_filteredItemsChanged'
        },

        /**
         * Neccessary to handle disabled items.
         */
        _tmpSelection: {
          type: String,
          observer: '_proxySelectionChange'
        },

        _gotFocus: {
          type: Boolean,
          value: false
        }
      },

      behaviors: [
        Polymer.IronA11yKeysBehavior
      ],

      hostAttributes: {
        'role': 'menu',
        'tabindex': '0'
      },

      listeners: {
        'blur': '_onBlurHost',
        'keydown': '_onKeyDown',
        'keyup': '_onKeyUp',
        'tap': '_onTap'
      },

      keyBindings: {
        // 'esc': '_onEscKey',
        'enter': '_onEnterKey'
      },

      setItems: function(newItems) {
        this.set('items', newItems);
        this.$.fuzzySearch.reload();
        this.searchTerm = '';
        this._restoreSelection();
      },

      addItem: function(item) {
        this.push(items, item);
        this.searchTerm = '';
        this.$.fuzzySearch.reload();
      },

      removeItem: function(index) {
        this.splice(index, 1);
        this.$.fuzzySearch.reload();
        this.searchTerm = '';
        this._restoreSelection();
      },

      _getElementByItem: function(item) {
        return Polymer.dom(this.$.list).querySelector('[item-id="' + this.get(this.paths.id, item) + '"]');
      },

      _getElementById: function(id) {
        return Polymer.dom(this.$.list).querySelector('[item-id="' + id + '"]');
      },

      _getItemById: function(id) {
        for (var i = 0, li = this.items.length; i < li; ++i) {
          if (this.get(this.paths.id, this.items[i]) == id) {
            return this.items[i];
          }
        }
      },

      _getItemIndex: function(item) {
        var id = this.get(this.paths.id, item);
        for (var i = 0, li = this._filteredItems.length; i < li; ++i) {
          if (this.get(this.paths.id, this._filteredItems[i]) == id) {
            return i;
          }
        }
      },

      /** Try to restore the item selection after some model manipulation was done */
      _restoreSelection: function() {
        if (!this.selection) return;

        var oldSelection = this.selection;
        this.$.list.select(null);
        this.async(function() {
          if (this._getElementById(oldSelection)) {
            this.$.list.select(oldSelection);
          }
        });
      },

      _proxySelectionChange: function(tmpSelection) {
        if (!tmpSelection) return;

        var item = this._getItemById(tmpSelection);
        if (!this._computeItemDisabled(item)) {
          this.selectedItem = item;
          this._setFocusedItem(this.selectedItem);
          this.selection = tmpSelection;
        }
      },

      _selectionChanged: function(select, oldSelection) {
        if (!oldSelection) return;

        this.async(function() {
          this._tmpSelection = select;
        }, 50);
      },

      /**
       * Generate's the ids for all items in the list.
       * @param  {Object} item The current item.
       * @return {String}      The id for the current item.
       */
      _computeItemId: function(item) {
        if (typeof this.pathFunctions.id == 'function') {
          return this.pathFunctions.id(item);
        } else {
          return this.get(this.paths.id, item);
        }
      },

      /**
       * Determines if a item is disabled.
       * This check can happen by providing a custom callback (set on `pathFunctions.disabled`).
       * If a custom callback is used, the `paths.disabled` attribute is ignored.
       *
       * Default check with `paths.disabled`:
       * If the property found under `paths.disabled` equals true, 'true' or '1' the item is considered disabled, otherwise enabled.
       *
       * @param  {Object} item The item to check.
       * @return {Boolean}      True if disabled, false if enabled.
       */
      _computeItemDisabled: function(item) {
        if (!item) return false;

        if (typeof this.pathFunctions.disabled == 'function') {
          return this.pathFunctions.disabled(item);
        }

        if (!this.paths.disabled) return false; // Not disabled.

        var disField = this.get(this.paths.disabled, item);
        if (disField == undefined) return false; // Not disabled.

        if (disField == true || disField == '1' || disField == 'true') return true; // DISABLED item!
      },

      /**
       * Fires the items-filtered event.
       */
      _filteredItemsChanged: function(filterItems) {
        this._restoreSelection();
        this.fire('items-filtered', this._filteredItems);
      },

      /** Accessibility stuff */

      _onBlurHost: function() {
        this._searchTerm = '';
      },

      _onTap: function() {
        this._gotFocus = true;
        if (this.selectedItem) {
          var el = this._getElementByItem(this.selectedItem);
          if (el) {
            this._setFocusedItem(this.selectedItem);
            return;
          }
        }
      },

      _onKeyUp: function(e) {
        // Element was focused by tab key.
        if (this.keyboardEventMatchesKeys(e, 'shift+tab tab')) {
          this.blur();

          this._gotFocus = true;
          if (this.selectedItem) {
            var el = this._getElementByItem(this.selectedItem);
            if (el) {
              this._setFocusedItem(this.selectedItem);
              return;
            }
          }

          if (this._filteredItems.length > 0) {
            for (var i in this._filteredItems) {
              if (!this._computeItemDisabled(this._filteredItems[i])) {
                this._setFocusedItem(this._filteredItems[i]);
                break;
              }
            }
          }
        }
      },

      _onKeyDown: function(e) {
        // Reset focus search on special keys.
        if (this.keyboardEventMatchesKeys(e, 'enter esc up down left right tab')) {
          this.searchTerm = '';
        }

        if (this.keyboardEventMatchesKeys(e, 'up left')) {
          this._focusPrev();
          e.preventDefault();
          return false;
        }

        if (this.keyboardEventMatchesKeys(e, 'down right')) {
          this._focusNext();
          e.preventDefault();
          return false;
        }

        var char = String.fromCharCode(e.keyCode);
        if (!char.match(/[^\x20-\x7E]+/)) {
          this.searchTerm += char;
        }
      },

      _onEnterKey: function() {
        if (this.focusedItem) {
          var id = this.get(this.paths.id, this.focusedItem);
          if (id) {
            this._proxySelectionChange(id);
            this.$.list.select(id);
          }
        }
      },

      _searchTermChanged: function(term) {
        if (term.length == 0) return;

        var result = this.$.fuzzySearch.sideSearch(term, this._filteredItems, this.paths.search);
        if (result.length > 0) {
          // Find first non-disabled item and focus it.
          for (var i in result) {
            if (!this._computeItemDisabled(result[i])) {
              this._setFocusedItem(result[i]);
              break;
            }
          }
        }
      },

      _filterTermChanged: function() {
        this.focusedItem = null;
      },

      /** Focus the previous item */
      _focusPrev: function() {
        var length = this._filteredItems.length;
        var currentIndex = this._getItemIndex(this.focusedItem);
        var index = (currentIndex - 1 + length) % length;

        // Find next 'previous' item that isn't disabled.
        while (this._computeItemDisabled(this._filteredItems[index])) {
          index = (index - 1 + length) % length;
          if (index == currentIndex) break;
        }
        this._setFocusedItem(this._filteredItems[index]);
      },

      /** Focus the next item */
      _focusNext: function() {
        var length = this._filteredItems.length;
        var currentIndex = this._getItemIndex(this.focusedItem);
        var index = (currentIndex + 1 + length) % length;

        // Find next 'previous' item that isn't disabled.
        while (this._computeItemDisabled(this._filteredItems[index])) {
          index = (index + 1 + length) % length;
          if (index == currentIndex) break;
        }
        this._setFocusedItem(this._filteredItems[index]);
      },

      /** Focus the selected item or the first item in the list. */
      _setFocusedItem: function(item) {
        if (!this._gotFocus) return; // Prevents focus on attach.

        if (this.focusedItem) {
          var oldEl = this._getElementByItem(this.focusedItem);
          if (oldEl) {
            if (oldEl.hasAttribute('disabled')) {
              oldEl.removeAttribute('tabindex');
            } else {
              oldEl.setAttribute('tabindex', '-1');
            }
          }
          this.focusedItem = null;
        }

        // Focus the new element.
        if (item) {
          var el = this._getElementByItem(item);
          if (el.hasAttribute('disabled')) return;

          this.focusedItem = item;
          el.setAttribute('tabindex', '0');
          el.focus();
        } else {
          // Remove focus from all items.
          Polymer.dom(this.$.list).querySelectorAll('[item-id]').forEach(function(el) {
            if (!el.hasAttribute('disabled')) {
              el.setAttribute('tabindex', '-1');
            }
            el.blur();
          });
        }
      }
    });
  </script>
</dom-module>
